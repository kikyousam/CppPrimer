# 第13章 拷贝控制
## 13.1 拷贝、赋值与销毁
### 13.1.1 拷贝构造函数
如果一个构造函数的第一个参数是对其自身类型的引用，且任何额外参数不含有默认值，则此构造函数就是拷贝构造函数
```c++
class Foo{
public:
    Foo();          //默认构造函数
    Foo(const Foo&);      //拷贝构造函数
}
```
拷贝构造函数在几种情况下会被隐式的调用，因此不支持explicit
- 合成拷贝构造函数
  编译器会默认构造一个拷贝构造函数。
  合成拷贝构造函数用来阻止我们拷贝该类类型的对象。合成拷贝构造函数会将其参数的成员逐个拷贝到正在创建对象中。编译器从给定对象依次将每个非static成员拷贝到正在创建的对象中。
  类类型成员会使用拷贝构造函数拷贝；内置类型成员直接拷贝。
- 拷贝初始化
  拷贝初始化和直接初始化的区别？
  直接初始化是要求编译器使用普通的函数匹配来选择与我们提供的参数相匹配的最佳构造函数。拷贝初始化是将右侧运算对象拷贝到正在创建的对象中，如果需要的话还会进行类型转换。
  拷贝初始化依赖拷贝构造函数或者是移动构造函数。
  拷贝初始化何时发生：
  1. =定义变量
  2. 将一个对象作为实参传递给一个非引用类型的形参
  3. 从一个返回类型为非引用类型函数返回一个对象
  4. 用花括号列表初始化一个数组中的元素或一个聚合类中的成员。
  5. 标准库容器调用insert或push成员，也会进行拷贝初始化。emplace成员进行的是直接初始化。
    基于第2条所以拷贝构造函数参数必须是引用，避免无限循环调用拷贝构造函数。
- 拷贝初始化的限制
  注意explicit以及是否能隐式转换
- 编译器可以绕过拷贝构造函数

### 13.1.2 拷贝赋值运算符

如果是拷贝初始化，则对应的是拷贝构造运算符。而如果是向声明对象，再进行赋值，则对应的是拷贝赋值运算符。
- 重载赋值运算符
  重载运算符的本质是函数重载运算符的参数表示运算符的运算对象。某些运算符，包括赋值运算符必须定义为成员函数。如果一个运算符是一个成员函数，其左侧运算对象的就绑定到隐式的this参数。

### 13.1.3 析构函数
- 析构函数完成什么工作
  隐式销毁一个内置指针类型的成员不会delete它所指向的对象。
- 什么时候使用析构函数
析构函数自身并不直接销毁成员，成员是在析构函数体之后隐含的析构阶段被销毁的。

### 13.1.4 三五法则
 - 需要析构函数的类也需要拷贝和赋值操作
  如果这个类有一个析构函数那么一定也需要一个拷贝构造函数和拷贝赋值运算符。
 - 需要拷贝操作的类也需要赋值操作，反之亦然

        
### 13.1.5 使用=default
  可以使用=default来显式地要求编译器生成合成的版本。合成的函数将隐式的声明为内联函数。
  不知道这有什么用

### 13.1.6 阻止拷贝
有些类（比如iostream）不需要拷贝构造函数和拷贝赋值函数，不定义也会有合成的拷贝构造函数，所以必须要阻止拷贝。

- 定义删除的函数
  可以将拷贝构造函数和拷贝赋值函数后面加上=delete。这样它们被定义成了deleted function.指出我们希望将它定义为删除的。

```C++
struct NoCopy{
  NoCopy()=defalut;
  NoCopy(const NoCopy&)=delete;
  NoCopy &operator=(const NoCopy&)=delete;
  ~NoCopy()=defalut;
  //其他成员
}
```

## 13.2 拷贝控制和资源管理

两种拷贝语义：使对象看起来像值还是像指针。
像值的比如string 像指针的比如智能指针 shared_ptr
我们如何拷贝指针成员决定了像HasPtr这样的类具有类值行为还是类指针行为。


### 13.2.1 行为像值的类

大多数赋值运算符组合了析构函数和拷贝构造函数的工作。
注意防范自赋值操作的重要性。一个好的模式时间右侧运算对象拷贝到一个局部临时变量中。当拷贝完成后，再进行销毁。

对于智能指针的类中可以没有析构函数，一般有拷贝构造函数和拷贝赋值函数。写起来比一般指针的拷贝函数要简单。

### 13.2.2 定义行为像指针的类
对于行为像指针的类，我们是需要析构函数的。否则会出现多次释放同一块内存。
一般像指针的类，用shared_ptr实现。
如果直接管理资源，可以使用引用计数。设计自己的引用计数。

- 引用计数
  构造函数初始化引用计数为1.拷贝构造函数递增共享的计数器。析构函数递减计数器。拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。
  如果计数器为0，拷贝赋值运算符就会销毁。


引用计数器的设计：放在动态内存中，拷贝或赋值对象时拷贝计数器的指针。

- 定义一个使用引用计数的类
```C++
using namespace std;
class HasPtr{
public:
  HasPtr(const string& s):ps(new string(s)),i(0),use(new size_t(1)){}
  HasPtr(const HasPtr& p):ps(p.ps),i(p.i),use(p.use){++*use;}
  HasPtr& operator=(const HasPtr& );
  ~HasPtr();
private:
  string* ps;
  int i;
  size_t* use;
}

HasPtr::~HasPtr(){
  if(--*use==0){
    delete ps;
    delete use;
  }
}

HasPtr& HasPtr::operator=(const HasPtr& rhs){
  ++*rhs.use;
  if(--*use==0){
    delete ps;
    delete use;
  }
  ps=rhs.ps;
  i=rhs.i;
  use=rhs.use;
  return *this;
}

```

## 13.3 交换操作
swap函数  类中 swap函数对于资源调用的类是一个资源优化的重要手段。
我们希望swap函数交换指针，而不是分配string的新副本

### 编写我们自己的swap函数
见tx13_3.h

### swap函数应该调用swap，而不是std::swap
我们自己定义的swap函数版本是由于标准哭的std::swap函数版本。

### 在赋值运算符中使用swap
copy and swap技术

swap(*this,rhs);

## 13.4 拷贝控制示例
一些类需要用拷贝控制成员来完成簿记操作和其他操作。


## 13.5 动态内存管理类
使用动态内存拷贝控制的类。

### StrVec类的设计

### 移动构造函数和std::move
标准库有移动构造函数和std::move两种机制来实现对string拷贝的避免。
move的标准库函数定义在utility头文件中。
首先，当用reallocate在新内存中构造string时，它必须调用move来表示希望使用string的移动构造函数。其次，通常不会为move提供一个using 声明。


## 13.6对象移动
对象移动可以避免拷贝，大幅度提高性能，而且对于某些类如IO类和unique_ptr这样的类包含不能被共享的资源，不能拷贝。

现在容器可以保存那些不可拷贝的类。
IO类和unique_ptr类可以移动但不能被拷贝。
### 13.6.1 右值引用
一个左值表达式表示对象的身份，一个右值表达式表示的是对象的值。可以用右值引用将一个对象的资源移动到另一个对象中。
#### 左值持久；右值短暂
右值引用只能绑定到临时对象。
#### 变量是左值
#### 标准库move函数
虽然不能直接将一个右值引用直接绑定到一个左值上，但我们可以显式地将一个左值转换为对应的右值引用类型。使用move函数。 头文件utility中 std::move

### 13.6.2 移动构造函数和移动赋值运算符

make_move_iterator函数可以将一个普通的迭代器转换成一个移动迭代器。移动迭代器的解引用是一个右值引用。

### 13.6.3 右值引用和成员函数
区分移动和拷贝的重载函数通常有一个版本接受一个const T&,而另一个版本接受一个T&&。
调用的区别就是实参是一个左值还是一个右值。

新标准库允许我们可以向右值进行赋值。但是也可以阻止向类成员赋值，只需要在拷贝赋值函数后面加上一个引用限定符&即可。引用限定符可以是&和&&，分别对应着左值和右值。
一个引用限定符可以是const成员函数。写法上引用限定符必须放在const成员函数后面。

#### 重载和引用函数
引用限定符可以让函数重载。
